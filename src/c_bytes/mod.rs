/// Encoding formats for bytes output.
pub mod encoding;
/// Output formatting for bytes generation.
pub mod output;

pub use encoding::BytesEncoding;
pub use output::BytesOutput;

use crate::error::GivError;
use rand::RngCore;


/// The default number of bytes to generate.
pub const DEFAULT_BYTE_LENGTH: usize = 32;

/// Generate random bytes.
///
/// # Arguments
///
/// - `length` The number of bytes to generate.
///
/// # Returns
///
/// A result containing the generated bytes or an error.
#[allow(dead_code)]
fn generate_bytes(length: usize) -> Result<Vec<u8>, GivError> {
    let mut bytes = vec![0u8; length];
    let mut rng = rand::rng();
    rng.fill_bytes(&mut bytes);
    Ok(bytes)
}


// Tests.
#[cfg(test)]
mod tests {
    use super::*;

    /// Test byte generation at various lengths.
    #[test]
    fn test_generate_bytes() {
        // The lengths to test.
        let lengths = [0, 1, 10, 32, 100, 1000];
        // For each length...
        for length in lengths {
            // Generate the bytes.
            let bytes = generate_bytes(length).unwrap();
            assert_eq!(bytes.len(), length);
        }
    }

    /// Test that generating two byte sequences produces different results.
    #[test]
    fn test_generate_bytes_randomness() {
        // Generate two sequences of 32 bytes.
        let bytes1 = generate_bytes(32).unwrap();
        let bytes2 = generate_bytes(32).unwrap();
        // They should be different (with overwhelming probability).
        assert_ne!(bytes1, bytes2);
    }
}

/// Encoding formats for bytes output.
mod encoding;
/// Output formatting for bytes generation.
mod output;

pub use encoding::BytesEncoding;

use crate::{app::AppContext, error::GivError};
use output::BytesOutput;
use rand::RngCore;

/// The default number of bytes to generate.
const DEFAULT_BYTE_LENGTH: usize = 32;

/// Generate random bytes.
///
/// # Arguments
///
/// - `length` The number of bytes to generate.
///
/// # Returns
///
/// A result containing the generated bytes or an error.
fn generate_bytes(length: usize) -> Result<Vec<u8>, GivError> {
    let mut bytes = vec![0u8; length];
    let mut rng = rand::rng();
    rng.fill_bytes(&mut bytes);
    Ok(bytes)
}

/// The 'bytes' command handler.
///
/// # Arguments
///
/// - `length` An optional length for the bytes to generate.
/// - `encoding` An optional encoding format for the output.
/// - `padding` Whether to use padding for base64 encoding.
/// - `ctx` The command context.
///
/// # Returns
///
/// A result indicating success or failure.
///
/// # Errors
///
/// Returns an error if:
/// - Raw encoding is requested with JSON output mode.
pub fn bytes_command(
    length: Option<usize>,
    encoding: Option<BytesEncoding>,
    padding: bool,
    ctx: &mut AppContext,
) -> Result<(), GivError> {
    let length = length.unwrap_or(DEFAULT_BYTE_LENGTH);
    let encoding = encoding.unwrap_or_else(BytesEncoding::default);

    // Check if raw encoding is requested with JSON output mode.
    if matches!(encoding, BytesEncoding::Raw) && ctx.output().is_json() {
        return Err(GivError::RawBytesNotSupportedInJson);
    }

    // Generate the random bytes.
    let bytes = generate_bytes(length)?;

    // Create output with the encoded bytes.
    let output = BytesOutput::new(&bytes, encoding, padding);

    // Output the bytes.
    ctx.output().output(&output);

    // Success.
    Ok(())
}

// Tests.
#[cfg(test)]
mod tests {
    use super::*;

    /// Test byte generation at various lengths.
    #[test]
    fn test_generate_bytes() {
        // The lengths to test.
        let lengths = [0, 1, 10, 32, 100, 1000];
        // For each length...
        for length in lengths {
            // Generate the bytes.
            let bytes = generate_bytes(length).unwrap();
            assert_eq!(bytes.len(), length);
        }
    }

    /// Test that generating two byte sequences produces different results.
    #[test]
    fn test_generate_bytes_randomness() {
        // Generate two sequences of 32 bytes.
        let bytes1 = generate_bytes(32).unwrap();
        let bytes2 = generate_bytes(32).unwrap();
        // They should be different (with overwhelming probability).
        assert_ne!(bytes1, bytes2);
    }
}

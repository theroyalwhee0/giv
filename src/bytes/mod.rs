/// Encoding formats for bytes output.
pub mod encoding;
/// Output formatting for bytes generation.
pub mod output;

pub use encoding::BytesEncoding;
pub use output::BytesOutput;

use crate::error::GivError;
use rand::RngCore;

/// The default number of bytes to generate.
pub const DEFAULT_BYTE_LENGTH: usize = 32;

/// Generate random bytes (internal helper).
///
/// # Arguments
///
/// - `length` The number of bytes to generate.
///
/// # Returns
///
/// A result containing the generated bytes or an error.
fn generate_bytes_raw(length: usize) -> Result<Vec<u8>, GivError> {
    let mut bytes = vec![0u8; length];
    let mut rng = rand::rng();
    rng.fill_bytes(&mut bytes);
    Ok(bytes)
}

/// Generate random bytes with encoding.
///
/// # Arguments
///
/// - `length` Optional number of bytes to generate. If `None`, uses [`DEFAULT_BYTE_LENGTH`] (32).
/// - `encoding` Optional encoding format. If `None`, uses default (Hex).
/// - `padding` Whether to use padding for base64 encoding.
///
/// # Returns
///
/// Returns a [`BytesOutput`] containing the encoded bytes.
///
/// # Errors
///
/// Returns an error if raw encoding is requested with JSON output (handled by caller).
///
/// # Examples
///
/// ```
/// use giv::bytes::{generate_bytes, BytesEncoding};
/// use giv::GivError;
///
/// # fn main() -> Result<(), GivError> {
/// // Generate bytes with default settings
/// let output = generate_bytes(None, None, false)?;
/// assert_eq!(output.length, 32);
/// assert_eq!(output.encoding, BytesEncoding::Base64);
///
/// // Generate bytes with custom settings
/// let output = generate_bytes(Some(16), Some(BytesEncoding::Base64), true)?;
/// assert_eq!(output.length, 16);
/// assert_eq!(output.encoding, BytesEncoding::Base64);
/// # Ok(())
/// # }
/// ```
pub fn generate_bytes(
    length: Option<usize>,
    encoding: Option<BytesEncoding>,
    padding: bool,
) -> Result<BytesOutput, GivError> {
    let length = length.unwrap_or(DEFAULT_BYTE_LENGTH);
    let encoding = encoding.unwrap_or_else(BytesEncoding::default);

    let raw_bytes = generate_bytes_raw(length)?;
    Ok(BytesOutput::new(&raw_bytes, encoding, padding))
}

// Tests.
#[cfg(test)]
mod tests {
    use super::*;

    /// Test byte generation at various lengths.
    #[test]
    fn test_generate_bytes_raw() {
        // The lengths to test.
        let lengths = [0, 1, 10, 32, 100, 1000];
        // For each length...
        for length in lengths {
            // Generate the bytes.
            let bytes = generate_bytes_raw(length).unwrap();
            assert_eq!(bytes.len(), length);
        }
    }

    /// Test that generating two byte sequences produces different results.
    #[test]
    fn test_generate_bytes_randomness() {
        // Generate two sequences of 32 bytes.
        let bytes1 = generate_bytes_raw(32).unwrap();
        let bytes2 = generate_bytes_raw(32).unwrap();
        // They should be different (with overwhelming probability).
        assert_ne!(bytes1, bytes2);
    }

    /// Test generate_bytes with default parameters.
    ///
    /// Verifies that `generate_bytes()` uses the default length (32 bytes)
    /// and encoding (Base64) when no parameters are specified.
    #[test]
    fn test_generate_bytes_defaults() {
        let output = generate_bytes(None, None, false).unwrap();
        assert_eq!(output.length, DEFAULT_BYTE_LENGTH);
        assert_eq!(output.encoding, BytesEncoding::default());
    }

    /// Test generate_bytes with custom length.
    ///
    /// Verifies that `generate_bytes()` respects the specified length
    /// parameter and generates the correct number of bytes.
    #[test]
    fn test_generate_bytes_custom_length() {
        let output = generate_bytes(Some(64), None, false).unwrap();
        assert_eq!(output.length, 64);
    }

    /// Test generate_bytes with custom encoding.
    ///
    /// Verifies that `generate_bytes()` correctly applies the specified
    /// encoding format to the generated bytes.
    #[test]
    fn test_generate_bytes_custom_encoding() {
        let output = generate_bytes(Some(16), Some(BytesEncoding::Hex), false).unwrap();
        assert_eq!(output.encoding, BytesEncoding::Hex);
        assert_eq!(output.length, 16);
        // Hex encoding produces 2 characters per byte
        assert_eq!(output.bytes.len(), 32);
    }

    /// Test generate_bytes with padding.
    ///
    /// Verifies that the padding parameter is correctly passed through
    /// to the output when using Base64 encoding.
    #[test]
    fn test_generate_bytes_with_padding() {
        let output = generate_bytes(Some(16), Some(BytesEncoding::Base64), true).unwrap();
        assert_eq!(output.padding, Some(true));
    }

    /// Test generate_bytes with all parameters specified.
    ///
    /// Verifies that `generate_bytes()` correctly handles all parameters
    /// being explicitly specified at once.
    #[test]
    fn test_generate_bytes_all_params() {
        let output = generate_bytes(Some(8), Some(BytesEncoding::Rust), false).unwrap();
        assert_eq!(output.length, 8);
        assert_eq!(output.encoding, BytesEncoding::Rust);
        assert!(output.bytes.starts_with("[u8; 8]"));
    }
}
